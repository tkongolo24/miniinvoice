{
  "version": 3,
  "sources": ["../../../utils/dist/rrweb-utils.js", "../src/error-stack-parser.ts", "../src/stringify.ts", "../src/index.ts"],
  "sourcesContent": ["const testableAccessors = {\n  Node: [\"childNodes\", \"parentNode\", \"parentElement\", \"textContent\"],\n  ShadowRoot: [\"host\", \"styleSheets\"],\n  Element: [\"shadowRoot\", \"querySelector\", \"querySelectorAll\"],\n  MutationObserver: []\n};\nconst testableMethods = {\n  Node: [\"contains\", \"getRootNode\"],\n  ShadowRoot: [\"getSelection\"],\n  Element: [],\n  MutationObserver: [\"constructor\"]\n};\nconst untaintedBasePrototype = {};\nconst isAngularZonePresent = () => {\n  return !!globalThis.Zone;\n};\nfunction getUntaintedPrototype(key) {\n  if (untaintedBasePrototype[key])\n    return untaintedBasePrototype[key];\n  const defaultObj = globalThis[key];\n  const defaultPrototype = defaultObj.prototype;\n  const accessorNames = key in testableAccessors ? testableAccessors[key] : void 0;\n  const isUntaintedAccessors = Boolean(\n    accessorNames && // @ts-expect-error 2345\n    accessorNames.every(\n      (accessor) => {\n        var _a, _b;\n        return Boolean(\n          (_b = (_a = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a.get) == null ? void 0 : _b.toString().includes(\"[native code]\")\n        );\n      }\n    )\n  );\n  const methodNames = key in testableMethods ? testableMethods[key] : void 0;\n  const isUntaintedMethods = Boolean(\n    methodNames && methodNames.every(\n      // @ts-expect-error 2345\n      (method) => {\n        var _a;\n        return typeof defaultPrototype[method] === \"function\" && ((_a = defaultPrototype[method]) == null ? void 0 : _a.toString().includes(\"[native code]\"));\n      }\n    )\n  );\n  if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent()) {\n    untaintedBasePrototype[key] = defaultObj.prototype;\n    return defaultObj.prototype;\n  }\n  try {\n    const iframeEl = document.createElement(\"iframe\");\n    document.body.appendChild(iframeEl);\n    const win = iframeEl.contentWindow;\n    if (!win) return defaultObj.prototype;\n    const untaintedObject = win[key].prototype;\n    document.body.removeChild(iframeEl);\n    if (!untaintedObject) return defaultPrototype;\n    return untaintedBasePrototype[key] = untaintedObject;\n  } catch {\n    return defaultPrototype;\n  }\n}\nconst untaintedAccessorCache = {};\nfunction getUntaintedAccessor(key, instance, accessor) {\n  var _a;\n  const cacheKey = `${key}.${String(accessor)}`;\n  if (untaintedAccessorCache[cacheKey])\n    return untaintedAccessorCache[cacheKey].call(\n      instance\n    );\n  const untaintedPrototype = getUntaintedPrototype(key);\n  const untaintedAccessor = (_a = Object.getOwnPropertyDescriptor(\n    untaintedPrototype,\n    accessor\n  )) == null ? void 0 : _a.get;\n  if (!untaintedAccessor) return instance[accessor];\n  untaintedAccessorCache[cacheKey] = untaintedAccessor;\n  return untaintedAccessor.call(instance);\n}\nconst untaintedMethodCache = {};\nfunction getUntaintedMethod(key, instance, method) {\n  const cacheKey = `${key}.${String(method)}`;\n  if (untaintedMethodCache[cacheKey])\n    return untaintedMethodCache[cacheKey].bind(\n      instance\n    );\n  const untaintedPrototype = getUntaintedPrototype(key);\n  const untaintedMethod = untaintedPrototype[method];\n  if (typeof untaintedMethod !== \"function\") return instance[method];\n  untaintedMethodCache[cacheKey] = untaintedMethod;\n  return untaintedMethod.bind(instance);\n}\nfunction childNodes(n) {\n  return getUntaintedAccessor(\"Node\", n, \"childNodes\");\n}\nfunction parentNode(n) {\n  return getUntaintedAccessor(\"Node\", n, \"parentNode\");\n}\nfunction parentElement(n) {\n  return getUntaintedAccessor(\"Node\", n, \"parentElement\");\n}\nfunction textContent(n) {\n  return getUntaintedAccessor(\"Node\", n, \"textContent\");\n}\nfunction contains(n, other) {\n  return getUntaintedMethod(\"Node\", n, \"contains\")(other);\n}\nfunction getRootNode(n) {\n  return getUntaintedMethod(\"Node\", n, \"getRootNode\")();\n}\nfunction host(n) {\n  if (!n || !(\"host\" in n)) return null;\n  return getUntaintedAccessor(\"ShadowRoot\", n, \"host\");\n}\nfunction styleSheets(n) {\n  return n.styleSheets;\n}\nfunction shadowRoot(n) {\n  if (!n || !(\"shadowRoot\" in n)) return null;\n  return getUntaintedAccessor(\"Element\", n, \"shadowRoot\");\n}\nfunction querySelector(n, selectors) {\n  return getUntaintedAccessor(\"Element\", n, \"querySelector\")(selectors);\n}\nfunction querySelectorAll(n, selectors) {\n  return getUntaintedAccessor(\"Element\", n, \"querySelectorAll\")(selectors);\n}\nfunction mutationObserverCtor() {\n  return getUntaintedPrototype(\"MutationObserver\").constructor;\n}\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return () => {\n      };\n    }\n    const original = source[name];\n    const wrapped = replacement(original);\n    if (typeof wrapped === \"function\") {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    }\n    source[name] = wrapped;\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {\n    };\n  }\n}\nconst index = {\n  childNodes,\n  parentNode,\n  parentElement,\n  textContent,\n  contains,\n  getRootNode,\n  host,\n  styleSheets,\n  shadowRoot,\n  querySelector,\n  querySelectorAll,\n  mutationObserver: mutationObserverCtor,\n  patch\n};\nexport {\n  childNodes,\n  contains,\n  index as default,\n  getRootNode,\n  getUntaintedAccessor,\n  getUntaintedMethod,\n  getUntaintedPrototype,\n  host,\n  isAngularZonePresent,\n  mutationObserverCtor,\n  parentElement,\n  parentNode,\n  patch,\n  querySelector,\n  querySelectorAll,\n  shadowRoot,\n  styleSheets,\n  textContent\n};\n//# sourceMappingURL=rrweb-utils.js.map\n", "/* eslint-disable @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return */\n/**\n * Class StackFrame is a fork of https://github.com/stacktracejs/stackframe/blob/master/stackframe.js\n * I fork it because:\n * 1. There are some build issues when importing this package.\n * 2. Rewrites into typescript give us a better type interface.\n * 3. StackFrame contains some functions we don't need.\n */\nexport class StackFrame {\n  private fileName: string;\n  private functionName: string;\n  private lineNumber?: number;\n  private columnNumber?: number;\n\n  constructor(obj: {\n    fileName?: string;\n    functionName?: string;\n    lineNumber?: number;\n    columnNumber?: number;\n  }) {\n    this.fileName = obj.fileName || '';\n    this.functionName = obj.functionName || '';\n    this.lineNumber = obj.lineNumber;\n    this.columnNumber = obj.columnNumber;\n  }\n\n  toString() {\n    const lineNumber = this.lineNumber || '';\n    const columnNumber = this.columnNumber || '';\n    if (this.functionName)\n      return `${this.functionName} (${this.fileName}:${lineNumber}:${columnNumber})`;\n    return `${this.fileName}:${lineNumber}:${columnNumber}`;\n  }\n}\n\n/**\n * ErrorStackParser is a fork of https://github.com/stacktracejs/error-stack-parser/blob/master/error-stack-parser.js\n * I fork it because:\n * 1. There are some build issues when importing this package.\n * 2. Rewrites into typescript give us a better type interface.\n */\nconst FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\nexport const ErrorStackParser = {\n  /**\n   * Given an Error object, extract the most information from it.\n   */\n  parse: function (error: Error): StackFrame[] {\n    // https://github.com/rrweb-io/rrweb/issues/782\n    if (!error) {\n      return [];\n    }\n    if (\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      typeof error.stacktrace !== 'undefined' ||\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      typeof error['opera#sourceloc'] !== 'undefined'\n    ) {\n      return this.parseOpera(\n        error as {\n          stacktrace?: string;\n          message: string;\n          stack?: string;\n        },\n      );\n    } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n      return this.parseV8OrIE(error as { stack: string });\n    } else if (error.stack) {\n      return this.parseFFOrSafari(error as { stack: string });\n    } else {\n      console.warn(\n        '[console-record-plugin]: Failed to parse error object:',\n        error,\n      );\n      return [];\n    }\n  },\n  // Separate line and column numbers from a string of the form: (URI:Line:Column)\n  extractLocation: function (urlLike: string) {\n    // Fail-fast but return locations like \"(native)\"\n    if (urlLike.indexOf(':') === -1) {\n      return [urlLike];\n    }\n\n    const regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n    const parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n    if (!parts) throw new Error(`Cannot parse given url: ${urlLike}`);\n    return [parts[1], parts[2] || undefined, parts[3] || undefined];\n  },\n  parseV8OrIE: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return !!line.match(CHROME_IE_STACK_REGEXP);\n    }, this);\n\n    return filtered.map(function (line) {\n      if (line.indexOf('(eval ') > -1) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        line = line\n          .replace(/eval code/g, 'eval')\n          .replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n      }\n      let sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n\n      // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n      // case it has spaces in it, as the string is split on \\s+ later on\n      const location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n\n      // remove the parenthesized location from the line, if it was matched\n      sanitizedLine = location\n        ? sanitizedLine.replace(location[0], '')\n        : sanitizedLine;\n\n      const tokens = sanitizedLine.split(/\\s+/).slice(1);\n      // if a location was matched, pass it to extractLocation() otherwise pop the last token\n      const locationParts = this.extractLocation(\n        location ? location[1] : tokens.pop(),\n      );\n      const functionName = tokens.join(' ') || undefined;\n      const fileName =\n        ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1\n          ? undefined\n          : locationParts[0];\n\n      return new StackFrame({\n        functionName,\n        fileName,\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n      });\n    }, this);\n  },\n  parseFFOrSafari: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n    }, this);\n\n    return filtered.map(function (line) {\n      // Throw away eval information until we implement stacktrace.js/stackframe#8\n      if (line.indexOf(' > eval') > -1) {\n        line = line.replace(\n          / line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,\n          ':$1',\n        );\n      }\n\n      if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n        // Safari eval frames only have function names and nothing else\n        return new StackFrame({\n          functionName: line,\n        });\n      } else {\n        const functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n        const matches = line.match(functionNameRegex);\n        const functionName = matches && matches[1] ? matches[1] : undefined;\n        const locationParts = this.extractLocation(\n          line.replace(functionNameRegex, ''),\n        );\n\n        return new StackFrame({\n          functionName,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n        });\n      }\n    }, this);\n  },\n  parseOpera: function (e: {\n    stacktrace?: string;\n    message: string;\n    stack?: string;\n  }): StackFrame[] {\n    if (\n      !e.stacktrace ||\n      (e.message.indexOf('\\n') > -1 &&\n        e.message.split('\\n').length > e.stacktrace.split('\\n').length)\n    ) {\n      return this.parseOpera9(e as { message: string });\n    } else if (!e.stack) {\n      return this.parseOpera10(e as { stacktrace: string });\n    } else {\n      return this.parseOpera11(e as { stack: string });\n    }\n  },\n  parseOpera9: function (e: { message: string }) {\n    const lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n    const lines = e.message.split('\\n');\n    const result = [];\n\n    for (let i = 2, len = lines.length; i < len; i += 2) {\n      const match = lineRE.exec(lines[i]);\n      if (match) {\n        result.push(\n          new StackFrame({\n            fileName: match[2],\n            lineNumber: parseFloat(match[1]),\n          }),\n        );\n      }\n    }\n\n    return result;\n  },\n  parseOpera10: function (e: { stacktrace: string }) {\n    const lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n    const lines = e.stacktrace.split('\\n');\n    const result = [];\n\n    for (let i = 0, len = lines.length; i < len; i += 2) {\n      const match = lineRE.exec(lines[i]);\n      if (match) {\n        result.push(\n          new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: parseFloat(match[1]),\n          }),\n        );\n      }\n    }\n\n    return result;\n  },\n  // Opera 10.65+ Error.stack very similar to FF/Safari\n  parseOpera11: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return (\n        !!line.match(FIREFOX_SAFARI_STACK_REGEXP) &&\n        !line.match(/^Error created at/)\n      );\n    }, this);\n\n    return filtered.map(function (line: string) {\n      const tokens = line.split('@');\n      const locationParts = this.extractLocation(tokens.pop());\n      const functionCall = tokens.shift() || '';\n      const functionName =\n        functionCall\n          .replace(/<anonymous function(: (\\w+))?>/, '$2')\n          .replace(/\\([^)]*\\)/g, '') || undefined;\n      return new StackFrame({\n        functionName,\n        fileName: locationParts[0],\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n      });\n    }, this);\n  },\n};\n", "/**\n * this file is used to serialize log message to string\n *\n */\n\nimport type { StringifyOptions } from './index';\n\n/**\n * transfer the node path in Event to string\n * @param node - the first node in a node path array\n */\nfunction pathToSelector(node: HTMLElement): string | '' {\n  if (!node || !node.outerHTML) {\n    return '';\n  }\n\n  let path = '';\n  while (node.parentElement) {\n    let name = node.localName;\n    if (!name) {\n      break;\n    }\n    name = name.toLowerCase();\n    const parent = node.parentElement;\n\n    const domSiblings = [];\n\n    if (parent.children && parent.children.length > 0) {\n      for (let i = 0; i < parent.children.length; i++) {\n        const sibling = parent.children[i];\n        if (sibling.localName && sibling.localName.toLowerCase) {\n          if (sibling.localName.toLowerCase() === name) {\n            domSiblings.push(sibling);\n          }\n        }\n      }\n    }\n\n    if (domSiblings.length > 1) {\n      name += `:eq(${domSiblings.indexOf(node)})`;\n    }\n    path = name + (path ? '>' + path : '');\n    node = parent;\n  }\n\n  return path;\n}\n\n/**\n * judge is object\n */\nfunction isObject(obj: unknown): boolean {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\n/**\n * judge the object's depth\n */\nfunction isObjTooDeep(obj: Record<string, unknown>, limit: number): boolean {\n  if (limit === 0) {\n    return true;\n  }\n\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    if (\n      isObject(obj[key]) &&\n      isObjTooDeep(obj[key] as Record<string, unknown>, limit - 1)\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * stringify any js object\n * @param obj - the object to stringify\n */\nexport function stringify(\n  obj: unknown,\n  stringifyOptions?: StringifyOptions,\n): string {\n  const options: StringifyOptions = {\n    numOfKeysLimit: 50,\n    depthOfLimit: 4,\n  };\n  Object.assign(options, stringifyOptions);\n  const stack: unknown[] = [];\n  const keys: unknown[] = [];\n  return JSON.stringify(\n    obj,\n    function (key, value: string | bigint | object | null | undefined) {\n      /**\n       * forked from https://github.com/moll/json-stringify-safe/blob/master/stringify.js\n       * to deCycle the object\n       */\n      if (stack.length > 0) {\n        const thisPos = stack.indexOf(this);\n        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n        ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n        if (~stack.indexOf(value)) {\n          if (stack[0] === value) {\n            value = '[Circular ~]';\n          } else {\n            value =\n              '[Circular ~.' +\n              keys.slice(0, stack.indexOf(value)).join('.') +\n              ']';\n          }\n        }\n      } else {\n        stack.push(value);\n      }\n      /* END of the FORK */\n\n      if (value === null) return value;\n      if (value === undefined) return 'undefined';\n      if (shouldIgnore(value as object)) {\n        return toString(value as object);\n      }\n      if (typeof value === 'bigint') {\n        return value.toString() + 'n';\n      }\n      if (value instanceof Event) {\n        const eventResult: Record<string, unknown> = {};\n        for (const eventKey in value) {\n          const eventValue = (value as unknown as Record<string, unknown>)[\n            eventKey\n          ];\n          if (Array.isArray(eventValue)) {\n            eventResult[eventKey] = pathToSelector(\n              (eventValue.length ? eventValue[0] : null) as HTMLElement,\n            );\n          } else {\n            eventResult[eventKey] = eventValue;\n          }\n        }\n        return eventResult;\n      } else if (value instanceof Node) {\n        if (value instanceof HTMLElement) {\n          return value ? value.outerHTML : '';\n        }\n        return value.nodeName;\n      } else if (value instanceof Error) {\n        return value.stack\n          ? value.stack + '\\nEnd of stack for Error object'\n          : value.name + ': ' + value.message;\n      }\n      return value;\n    },\n  );\n\n  /**\n   * whether we should ignore obj's info and call toString() function instead\n   */\n  function shouldIgnore(_obj: object): boolean {\n    // outof keys limit\n    if (isObject(_obj) && Object.keys(_obj).length > options.numOfKeysLimit) {\n      return true;\n    }\n\n    // is function or bigint\n    if (typeof _obj === 'function') {\n      return true;\n    }\n\n    /**\n     * judge object's depth to avoid browser's OOM\n     *\n     * issues: https://github.com/rrweb-io/rrweb/issues/653\n     */\n    if (\n      isObject(_obj) &&\n      isObjTooDeep(_obj as Record<string, unknown>, options.depthOfLimit)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * limit the toString() result according to option\n   */\n  function toString(_obj: object): string {\n    let str = _obj.toString();\n    if (options.stringLengthLimit && str.length > options.stringLengthLimit) {\n      str = `${str.slice(0, options.stringLengthLimit)}...`;\n    }\n    return str;\n  }\n}\n", "import type { listenerHandler, RecordPlugin, IWindow } from '@rrweb/types';\nimport { patch } from '@rrweb/utils';\nimport { ErrorStackParser, StackFrame } from './error-stack-parser';\nimport { stringify } from './stringify';\n\nexport type StringifyOptions = {\n  // limit of string length\n  stringLengthLimit?: number;\n  /**\n   * limit of number of keys in an object\n   * if an object contains more keys than this limit, we would call its toString function directly\n   */\n  numOfKeysLimit: number;\n  /**\n   * limit number of depth in an object\n   * if an object is too deep, toString process may cause browser OOM\n   */\n  depthOfLimit: number;\n};\n\ntype LogRecordOptions = {\n  level?: LogLevel[];\n  lengthThreshold?: number;\n  stringifyOptions?: StringifyOptions;\n  logger?: Logger | 'console';\n};\n\nconst defaultLogOptions: LogRecordOptions = {\n  level: [\n    'assert',\n    'clear',\n    'count',\n    'countReset',\n    'debug',\n    'dir',\n    'dirxml',\n    'error',\n    'group',\n    'groupCollapsed',\n    'groupEnd',\n    'info',\n    'log',\n    'table',\n    'time',\n    'timeEnd',\n    'timeLog',\n    'trace',\n    'warn',\n  ],\n  lengthThreshold: 1000,\n  logger: 'console',\n};\n\nexport type LogData = {\n  level: LogLevel;\n  trace: string[];\n  payload: string[];\n};\n\ntype logCallback = (p: LogData) => void;\n\n/* fork from interface Console */\n// all kinds of console functions\nexport type Logger = {\n  assert?: typeof console.assert;\n  clear?: typeof console.clear;\n  count?: typeof console.count;\n  countReset?: typeof console.countReset;\n  debug?: typeof console.debug;\n  dir?: typeof console.dir;\n  dirxml?: typeof console.dirxml;\n  error?: typeof console.error;\n  group?: typeof console.group;\n  groupCollapsed?: typeof console.groupCollapsed;\n  groupEnd?: () => void;\n  info?: typeof console.info;\n  log?: typeof console.log;\n  table?: typeof console.table;\n  time?: typeof console.time;\n  timeEnd?: typeof console.timeEnd;\n  timeLog?: typeof console.timeLog;\n  trace?: typeof console.trace;\n  warn?: typeof console.warn;\n};\n\nexport type LogLevel = keyof Logger;\n\nfunction initLogObserver(\n  cb: logCallback,\n  win: IWindow, // top window or in an iframe\n  options: LogRecordOptions,\n): listenerHandler {\n  const logOptions = (\n    options ? Object.assign({}, defaultLogOptions, options) : defaultLogOptions\n  ) as {\n    level: LogLevel[];\n    lengthThreshold: number;\n    stringifyOptions?: StringifyOptions;\n    logger: Logger | 'console';\n  };\n  const loggerType = logOptions.logger;\n  if (!loggerType) {\n    return () => {\n      //\n    };\n  }\n  let logger: Logger;\n  if (typeof loggerType === 'string') {\n    logger = win[loggerType];\n  } else {\n    logger = loggerType;\n  }\n  let logCount = 0;\n  let inStack = false;\n  const cancelHandlers: listenerHandler[] = [];\n  // add listener to thrown errors\n  if (logOptions.level.includes('error')) {\n    const errorHandler = (event: ErrorEvent) => {\n      const message = event.message,\n        error = event.error as Error;\n      const trace: string[] = ErrorStackParser.parse(error).map(\n        (stackFrame: StackFrame) => stackFrame.toString(),\n      );\n      const payload = [stringify(message, logOptions.stringifyOptions)];\n      cb({\n        level: 'error',\n        trace,\n        payload,\n      });\n    };\n    win.addEventListener('error', errorHandler);\n    cancelHandlers.push(() => {\n      win.removeEventListener('error', errorHandler);\n    });\n    const unhandledrejectionHandler = (event: PromiseRejectionEvent) => {\n      let error: Error;\n      let payload: string[];\n      if (event.reason instanceof Error) {\n        error = event.reason;\n        payload = [\n          stringify(\n            `Uncaught (in promise) ${error.name}: ${error.message}`,\n            logOptions.stringifyOptions,\n          ),\n        ];\n      } else {\n        error = new Error();\n        payload = [\n          stringify('Uncaught (in promise)', logOptions.stringifyOptions),\n          stringify(event.reason, logOptions.stringifyOptions),\n        ];\n      }\n      const trace: string[] = ErrorStackParser.parse(error).map(\n        (stackFrame: StackFrame) => stackFrame.toString(),\n      );\n      cb({\n        level: 'error',\n        trace,\n        payload,\n      });\n    };\n    win.addEventListener('unhandledrejection', unhandledrejectionHandler);\n    cancelHandlers.push(() => {\n      win.removeEventListener('unhandledrejection', unhandledrejectionHandler);\n    });\n  }\n  for (const levelType of logOptions.level) {\n    cancelHandlers.push(replace(logger, levelType));\n  }\n  return () => {\n    cancelHandlers.forEach((h) => h());\n  };\n\n  /**\n   * replace the original console function and record logs\n   * @param logger - the logger object such as Console\n   * @param level - the name of log function to be replaced\n   */\n  function replace(_logger: Logger, level: LogLevel) {\n    if (!_logger[level]) {\n      return () => {\n        //\n      };\n    }\n    // replace the logger.{level}. return a restore function\n    return patch(\n      _logger,\n      level,\n      (original: (...args: Array<unknown>) => void) => {\n        return (...args: Array<unknown>) => {\n          original.apply(this, args);\n\n          if (level === 'assert' && !!args[0]) {\n            // assert does not log if the first argument evaluates to true\n            return;\n          }\n\n          if (inStack) {\n            // If we are already in a stack this means something from the following code is calling a console method\n            // likely a proxy method called from stringify. We don't want to log this as it will cause an infinite loop\n            return;\n          }\n          inStack = true;\n          try {\n            const trace = ErrorStackParser.parse(new Error())\n              .map((stackFrame: StackFrame) => stackFrame.toString())\n              .splice(1); // splice(1) to omit the hijacked log function\n\n            // assert does not log its first arg, that's only used for deciding whether to log\n            const argsForPayload = level === 'assert' ? args.slice(1) : args;\n\n            const payload = argsForPayload.map((s) =>\n              stringify(s, logOptions.stringifyOptions),\n            );\n            logCount++;\n            if (logCount < logOptions.lengthThreshold) {\n              cb({\n                level,\n                trace,\n                payload,\n              });\n            } else if (logCount === logOptions.lengthThreshold) {\n              // notify the user\n              cb({\n                level: 'warn',\n                trace: [],\n                payload: [\n                  stringify('The number of log records reached the threshold.'),\n                ],\n              });\n            }\n          } catch (error) {\n            original('rrweb logger error:', error, ...args);\n          } finally {\n            inStack = false;\n          }\n        };\n      },\n    );\n  }\n}\n\nexport const PLUGIN_NAME = 'rrweb/console@1';\n\nexport const getRecordConsolePlugin: (\n  options?: LogRecordOptions,\n) => RecordPlugin = (options) => ({\n  name: PLUGIN_NAME,\n  observer: initLogObserver,\n  options: options,\n});\n"],
  "mappings": "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",
  "names": ["patch", "source", "name", "replacement", "original", "wrapped", "e", "StackFrame", "obj", "__publicField", "lineNumber", "columnNumber", "FIREFOX_SAFARI_STACK_REGEXP", "CHROME_IE_STACK_REGEXP", "SAFARI_NATIVE_CODE_REGEXP", "ErrorStackParser", "error", "urlLike", "parts", "line", "sanitizedLine", "location", "tokens", "locationParts", "functionName", "fileName", "functionNameRegex", "matches", "lineRE", "lines", "result", "len", "match", "pathToSelector", "node", "path", "parent", "domSiblings", "i", "sibling", "isObject", "isObjTooDeep", "limit", "keys", "key", "stringify", "stringifyOptions", "options", "stack", "value", "thisPos", "shouldIgnore", "toString", "eventResult", "eventKey", "eventValue", "_obj", "str", "defaultLogOptions", "initLogObserver", "cb", "win", "logOptions", "loggerType", "logger", "logCount", "inStack", "cancelHandlers", "errorHandler", "event", "message", "trace", "stackFrame", "payload", "unhandledrejectionHandler", "levelType", "replace", "h", "_logger", "level", "args", "s", "PLUGIN_NAME", "getRecordConsolePlugin"]
}
