{"version":3,"file":"rrweb-plugin-console-record.js","sources":["../../../utils/dist/rrweb-utils.js","../src/error-stack-parser.ts","../src/stringify.ts","../src/index.ts"],"sourcesContent":["const testableAccessors = {\n  Node: [\"childNodes\", \"parentNode\", \"parentElement\", \"textContent\"],\n  ShadowRoot: [\"host\", \"styleSheets\"],\n  Element: [\"shadowRoot\", \"querySelector\", \"querySelectorAll\"],\n  MutationObserver: []\n};\nconst testableMethods = {\n  Node: [\"contains\", \"getRootNode\"],\n  ShadowRoot: [\"getSelection\"],\n  Element: [],\n  MutationObserver: [\"constructor\"]\n};\nconst untaintedBasePrototype = {};\nconst isAngularZonePresent = () => {\n  return !!globalThis.Zone;\n};\nfunction getUntaintedPrototype(key) {\n  if (untaintedBasePrototype[key])\n    return untaintedBasePrototype[key];\n  const defaultObj = globalThis[key];\n  const defaultPrototype = defaultObj.prototype;\n  const accessorNames = key in testableAccessors ? testableAccessors[key] : void 0;\n  const isUntaintedAccessors = Boolean(\n    accessorNames && // @ts-expect-error 2345\n    accessorNames.every(\n      (accessor) => {\n        var _a, _b;\n        return Boolean(\n          (_b = (_a = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a.get) == null ? void 0 : _b.toString().includes(\"[native code]\")\n        );\n      }\n    )\n  );\n  const methodNames = key in testableMethods ? testableMethods[key] : void 0;\n  const isUntaintedMethods = Boolean(\n    methodNames && methodNames.every(\n      // @ts-expect-error 2345\n      (method) => {\n        var _a;\n        return typeof defaultPrototype[method] === \"function\" && ((_a = defaultPrototype[method]) == null ? void 0 : _a.toString().includes(\"[native code]\"));\n      }\n    )\n  );\n  if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent()) {\n    untaintedBasePrototype[key] = defaultObj.prototype;\n    return defaultObj.prototype;\n  }\n  try {\n    const iframeEl = document.createElement(\"iframe\");\n    document.body.appendChild(iframeEl);\n    const win = iframeEl.contentWindow;\n    if (!win) return defaultObj.prototype;\n    const untaintedObject = win[key].prototype;\n    document.body.removeChild(iframeEl);\n    if (!untaintedObject) return defaultPrototype;\n    return untaintedBasePrototype[key] = untaintedObject;\n  } catch {\n    return defaultPrototype;\n  }\n}\nconst untaintedAccessorCache = {};\nfunction getUntaintedAccessor(key, instance, accessor) {\n  var _a;\n  const cacheKey = `${key}.${String(accessor)}`;\n  if (untaintedAccessorCache[cacheKey])\n    return untaintedAccessorCache[cacheKey].call(\n      instance\n    );\n  const untaintedPrototype = getUntaintedPrototype(key);\n  const untaintedAccessor = (_a = Object.getOwnPropertyDescriptor(\n    untaintedPrototype,\n    accessor\n  )) == null ? void 0 : _a.get;\n  if (!untaintedAccessor) return instance[accessor];\n  untaintedAccessorCache[cacheKey] = untaintedAccessor;\n  return untaintedAccessor.call(instance);\n}\nconst untaintedMethodCache = {};\nfunction getUntaintedMethod(key, instance, method) {\n  const cacheKey = `${key}.${String(method)}`;\n  if (untaintedMethodCache[cacheKey])\n    return untaintedMethodCache[cacheKey].bind(\n      instance\n    );\n  const untaintedPrototype = getUntaintedPrototype(key);\n  const untaintedMethod = untaintedPrototype[method];\n  if (typeof untaintedMethod !== \"function\") return instance[method];\n  untaintedMethodCache[cacheKey] = untaintedMethod;\n  return untaintedMethod.bind(instance);\n}\nfunction childNodes(n) {\n  return getUntaintedAccessor(\"Node\", n, \"childNodes\");\n}\nfunction parentNode(n) {\n  return getUntaintedAccessor(\"Node\", n, \"parentNode\");\n}\nfunction parentElement(n) {\n  return getUntaintedAccessor(\"Node\", n, \"parentElement\");\n}\nfunction textContent(n) {\n  return getUntaintedAccessor(\"Node\", n, \"textContent\");\n}\nfunction contains(n, other) {\n  return getUntaintedMethod(\"Node\", n, \"contains\")(other);\n}\nfunction getRootNode(n) {\n  return getUntaintedMethod(\"Node\", n, \"getRootNode\")();\n}\nfunction host(n) {\n  if (!n || !(\"host\" in n)) return null;\n  return getUntaintedAccessor(\"ShadowRoot\", n, \"host\");\n}\nfunction styleSheets(n) {\n  return n.styleSheets;\n}\nfunction shadowRoot(n) {\n  if (!n || !(\"shadowRoot\" in n)) return null;\n  return getUntaintedAccessor(\"Element\", n, \"shadowRoot\");\n}\nfunction querySelector(n, selectors) {\n  return getUntaintedAccessor(\"Element\", n, \"querySelector\")(selectors);\n}\nfunction querySelectorAll(n, selectors) {\n  return getUntaintedAccessor(\"Element\", n, \"querySelectorAll\")(selectors);\n}\nfunction mutationObserverCtor() {\n  return getUntaintedPrototype(\"MutationObserver\").constructor;\n}\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return () => {\n      };\n    }\n    const original = source[name];\n    const wrapped = replacement(original);\n    if (typeof wrapped === \"function\") {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    }\n    source[name] = wrapped;\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {\n    };\n  }\n}\nconst index = {\n  childNodes,\n  parentNode,\n  parentElement,\n  textContent,\n  contains,\n  getRootNode,\n  host,\n  styleSheets,\n  shadowRoot,\n  querySelector,\n  querySelectorAll,\n  mutationObserver: mutationObserverCtor,\n  patch\n};\nexport {\n  childNodes,\n  contains,\n  index as default,\n  getRootNode,\n  getUntaintedAccessor,\n  getUntaintedMethod,\n  getUntaintedPrototype,\n  host,\n  isAngularZonePresent,\n  mutationObserverCtor,\n  parentElement,\n  parentNode,\n  patch,\n  querySelector,\n  querySelectorAll,\n  shadowRoot,\n  styleSheets,\n  textContent\n};\n//# sourceMappingURL=rrweb-utils.js.map\n","/* eslint-disable @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return */\n/**\n * Class StackFrame is a fork of https://github.com/stacktracejs/stackframe/blob/master/stackframe.js\n * I fork it because:\n * 1. There are some build issues when importing this package.\n * 2. Rewrites into typescript give us a better type interface.\n * 3. StackFrame contains some functions we don't need.\n */\nexport class StackFrame {\n  private fileName: string;\n  private functionName: string;\n  private lineNumber?: number;\n  private columnNumber?: number;\n\n  constructor(obj: {\n    fileName?: string;\n    functionName?: string;\n    lineNumber?: number;\n    columnNumber?: number;\n  }) {\n    this.fileName = obj.fileName || '';\n    this.functionName = obj.functionName || '';\n    this.lineNumber = obj.lineNumber;\n    this.columnNumber = obj.columnNumber;\n  }\n\n  toString() {\n    const lineNumber = this.lineNumber || '';\n    const columnNumber = this.columnNumber || '';\n    if (this.functionName)\n      return `${this.functionName} (${this.fileName}:${lineNumber}:${columnNumber})`;\n    return `${this.fileName}:${lineNumber}:${columnNumber}`;\n  }\n}\n\n/**\n * ErrorStackParser is a fork of https://github.com/stacktracejs/error-stack-parser/blob/master/error-stack-parser.js\n * I fork it because:\n * 1. There are some build issues when importing this package.\n * 2. Rewrites into typescript give us a better type interface.\n */\nconst FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\nexport const ErrorStackParser = {\n  /**\n   * Given an Error object, extract the most information from it.\n   */\n  parse: function (error: Error): StackFrame[] {\n    // https://github.com/rrweb-io/rrweb/issues/782\n    if (!error) {\n      return [];\n    }\n    if (\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      typeof error.stacktrace !== 'undefined' ||\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      typeof error['opera#sourceloc'] !== 'undefined'\n    ) {\n      return this.parseOpera(\n        error as {\n          stacktrace?: string;\n          message: string;\n          stack?: string;\n        },\n      );\n    } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n      return this.parseV8OrIE(error as { stack: string });\n    } else if (error.stack) {\n      return this.parseFFOrSafari(error as { stack: string });\n    } else {\n      console.warn(\n        '[console-record-plugin]: Failed to parse error object:',\n        error,\n      );\n      return [];\n    }\n  },\n  // Separate line and column numbers from a string of the form: (URI:Line:Column)\n  extractLocation: function (urlLike: string) {\n    // Fail-fast but return locations like \"(native)\"\n    if (urlLike.indexOf(':') === -1) {\n      return [urlLike];\n    }\n\n    const regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n    const parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n    if (!parts) throw new Error(`Cannot parse given url: ${urlLike}`);\n    return [parts[1], parts[2] || undefined, parts[3] || undefined];\n  },\n  parseV8OrIE: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return !!line.match(CHROME_IE_STACK_REGEXP);\n    }, this);\n\n    return filtered.map(function (line) {\n      if (line.indexOf('(eval ') > -1) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        line = line\n          .replace(/eval code/g, 'eval')\n          .replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n      }\n      let sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n\n      // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n      // case it has spaces in it, as the string is split on \\s+ later on\n      const location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n\n      // remove the parenthesized location from the line, if it was matched\n      sanitizedLine = location\n        ? sanitizedLine.replace(location[0], '')\n        : sanitizedLine;\n\n      const tokens = sanitizedLine.split(/\\s+/).slice(1);\n      // if a location was matched, pass it to extractLocation() otherwise pop the last token\n      const locationParts = this.extractLocation(\n        location ? location[1] : tokens.pop(),\n      );\n      const functionName = tokens.join(' ') || undefined;\n      const fileName =\n        ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1\n          ? undefined\n          : locationParts[0];\n\n      return new StackFrame({\n        functionName,\n        fileName,\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n      });\n    }, this);\n  },\n  parseFFOrSafari: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n    }, this);\n\n    return filtered.map(function (line) {\n      // Throw away eval information until we implement stacktrace.js/stackframe#8\n      if (line.indexOf(' > eval') > -1) {\n        line = line.replace(\n          / line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,\n          ':$1',\n        );\n      }\n\n      if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n        // Safari eval frames only have function names and nothing else\n        return new StackFrame({\n          functionName: line,\n        });\n      } else {\n        const functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n        const matches = line.match(functionNameRegex);\n        const functionName = matches && matches[1] ? matches[1] : undefined;\n        const locationParts = this.extractLocation(\n          line.replace(functionNameRegex, ''),\n        );\n\n        return new StackFrame({\n          functionName,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n        });\n      }\n    }, this);\n  },\n  parseOpera: function (e: {\n    stacktrace?: string;\n    message: string;\n    stack?: string;\n  }): StackFrame[] {\n    if (\n      !e.stacktrace ||\n      (e.message.indexOf('\\n') > -1 &&\n        e.message.split('\\n').length > e.stacktrace.split('\\n').length)\n    ) {\n      return this.parseOpera9(e as { message: string });\n    } else if (!e.stack) {\n      return this.parseOpera10(e as { stacktrace: string });\n    } else {\n      return this.parseOpera11(e as { stack: string });\n    }\n  },\n  parseOpera9: function (e: { message: string }) {\n    const lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n    const lines = e.message.split('\\n');\n    const result = [];\n\n    for (let i = 2, len = lines.length; i < len; i += 2) {\n      const match = lineRE.exec(lines[i]);\n      if (match) {\n        result.push(\n          new StackFrame({\n            fileName: match[2],\n            lineNumber: parseFloat(match[1]),\n          }),\n        );\n      }\n    }\n\n    return result;\n  },\n  parseOpera10: function (e: { stacktrace: string }) {\n    const lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n    const lines = e.stacktrace.split('\\n');\n    const result = [];\n\n    for (let i = 0, len = lines.length; i < len; i += 2) {\n      const match = lineRE.exec(lines[i]);\n      if (match) {\n        result.push(\n          new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: parseFloat(match[1]),\n          }),\n        );\n      }\n    }\n\n    return result;\n  },\n  // Opera 10.65+ Error.stack very similar to FF/Safari\n  parseOpera11: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return (\n        !!line.match(FIREFOX_SAFARI_STACK_REGEXP) &&\n        !line.match(/^Error created at/)\n      );\n    }, this);\n\n    return filtered.map(function (line: string) {\n      const tokens = line.split('@');\n      const locationParts = this.extractLocation(tokens.pop());\n      const functionCall = tokens.shift() || '';\n      const functionName =\n        functionCall\n          .replace(/<anonymous function(: (\\w+))?>/, '$2')\n          .replace(/\\([^)]*\\)/g, '') || undefined;\n      return new StackFrame({\n        functionName,\n        fileName: locationParts[0],\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n      });\n    }, this);\n  },\n};\n","/**\n * this file is used to serialize log message to string\n *\n */\n\nimport type { StringifyOptions } from './index';\n\n/**\n * transfer the node path in Event to string\n * @param node - the first node in a node path array\n */\nfunction pathToSelector(node: HTMLElement): string | '' {\n  if (!node || !node.outerHTML) {\n    return '';\n  }\n\n  let path = '';\n  while (node.parentElement) {\n    let name = node.localName;\n    if (!name) {\n      break;\n    }\n    name = name.toLowerCase();\n    const parent = node.parentElement;\n\n    const domSiblings = [];\n\n    if (parent.children && parent.children.length > 0) {\n      for (let i = 0; i < parent.children.length; i++) {\n        const sibling = parent.children[i];\n        if (sibling.localName && sibling.localName.toLowerCase) {\n          if (sibling.localName.toLowerCase() === name) {\n            domSiblings.push(sibling);\n          }\n        }\n      }\n    }\n\n    if (domSiblings.length > 1) {\n      name += `:eq(${domSiblings.indexOf(node)})`;\n    }\n    path = name + (path ? '>' + path : '');\n    node = parent;\n  }\n\n  return path;\n}\n\n/**\n * judge is object\n */\nfunction isObject(obj: unknown): boolean {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\n/**\n * judge the object's depth\n */\nfunction isObjTooDeep(obj: Record<string, unknown>, limit: number): boolean {\n  if (limit === 0) {\n    return true;\n  }\n\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    if (\n      isObject(obj[key]) &&\n      isObjTooDeep(obj[key] as Record<string, unknown>, limit - 1)\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * stringify any js object\n * @param obj - the object to stringify\n */\nexport function stringify(\n  obj: unknown,\n  stringifyOptions?: StringifyOptions,\n): string {\n  const options: StringifyOptions = {\n    numOfKeysLimit: 50,\n    depthOfLimit: 4,\n  };\n  Object.assign(options, stringifyOptions);\n  const stack: unknown[] = [];\n  const keys: unknown[] = [];\n  return JSON.stringify(\n    obj,\n    function (key, value: string | bigint | object | null | undefined) {\n      /**\n       * forked from https://github.com/moll/json-stringify-safe/blob/master/stringify.js\n       * to deCycle the object\n       */\n      if (stack.length > 0) {\n        const thisPos = stack.indexOf(this);\n        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n        ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n        if (~stack.indexOf(value)) {\n          if (stack[0] === value) {\n            value = '[Circular ~]';\n          } else {\n            value =\n              '[Circular ~.' +\n              keys.slice(0, stack.indexOf(value)).join('.') +\n              ']';\n          }\n        }\n      } else {\n        stack.push(value);\n      }\n      /* END of the FORK */\n\n      if (value === null) return value;\n      if (value === undefined) return 'undefined';\n      if (shouldIgnore(value as object)) {\n        return toString(value as object);\n      }\n      if (typeof value === 'bigint') {\n        return value.toString() + 'n';\n      }\n      if (value instanceof Event) {\n        const eventResult: Record<string, unknown> = {};\n        for (const eventKey in value) {\n          const eventValue = (value as unknown as Record<string, unknown>)[\n            eventKey\n          ];\n          if (Array.isArray(eventValue)) {\n            eventResult[eventKey] = pathToSelector(\n              (eventValue.length ? eventValue[0] : null) as HTMLElement,\n            );\n          } else {\n            eventResult[eventKey] = eventValue;\n          }\n        }\n        return eventResult;\n      } else if (value instanceof Node) {\n        if (value instanceof HTMLElement) {\n          return value ? value.outerHTML : '';\n        }\n        return value.nodeName;\n      } else if (value instanceof Error) {\n        return value.stack\n          ? value.stack + '\\nEnd of stack for Error object'\n          : value.name + ': ' + value.message;\n      }\n      return value;\n    },\n  );\n\n  /**\n   * whether we should ignore obj's info and call toString() function instead\n   */\n  function shouldIgnore(_obj: object): boolean {\n    // outof keys limit\n    if (isObject(_obj) && Object.keys(_obj).length > options.numOfKeysLimit) {\n      return true;\n    }\n\n    // is function or bigint\n    if (typeof _obj === 'function') {\n      return true;\n    }\n\n    /**\n     * judge object's depth to avoid browser's OOM\n     *\n     * issues: https://github.com/rrweb-io/rrweb/issues/653\n     */\n    if (\n      isObject(_obj) &&\n      isObjTooDeep(_obj as Record<string, unknown>, options.depthOfLimit)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * limit the toString() result according to option\n   */\n  function toString(_obj: object): string {\n    let str = _obj.toString();\n    if (options.stringLengthLimit && str.length > options.stringLengthLimit) {\n      str = `${str.slice(0, options.stringLengthLimit)}...`;\n    }\n    return str;\n  }\n}\n","import type { listenerHandler, RecordPlugin, IWindow } from '@rrweb/types';\nimport { patch } from '@rrweb/utils';\nimport { ErrorStackParser, StackFrame } from './error-stack-parser';\nimport { stringify } from './stringify';\n\nexport type StringifyOptions = {\n  // limit of string length\n  stringLengthLimit?: number;\n  /**\n   * limit of number of keys in an object\n   * if an object contains more keys than this limit, we would call its toString function directly\n   */\n  numOfKeysLimit: number;\n  /**\n   * limit number of depth in an object\n   * if an object is too deep, toString process may cause browser OOM\n   */\n  depthOfLimit: number;\n};\n\ntype LogRecordOptions = {\n  level?: LogLevel[];\n  lengthThreshold?: number;\n  stringifyOptions?: StringifyOptions;\n  logger?: Logger | 'console';\n};\n\nconst defaultLogOptions: LogRecordOptions = {\n  level: [\n    'assert',\n    'clear',\n    'count',\n    'countReset',\n    'debug',\n    'dir',\n    'dirxml',\n    'error',\n    'group',\n    'groupCollapsed',\n    'groupEnd',\n    'info',\n    'log',\n    'table',\n    'time',\n    'timeEnd',\n    'timeLog',\n    'trace',\n    'warn',\n  ],\n  lengthThreshold: 1000,\n  logger: 'console',\n};\n\nexport type LogData = {\n  level: LogLevel;\n  trace: string[];\n  payload: string[];\n};\n\ntype logCallback = (p: LogData) => void;\n\n/* fork from interface Console */\n// all kinds of console functions\nexport type Logger = {\n  assert?: typeof console.assert;\n  clear?: typeof console.clear;\n  count?: typeof console.count;\n  countReset?: typeof console.countReset;\n  debug?: typeof console.debug;\n  dir?: typeof console.dir;\n  dirxml?: typeof console.dirxml;\n  error?: typeof console.error;\n  group?: typeof console.group;\n  groupCollapsed?: typeof console.groupCollapsed;\n  groupEnd?: () => void;\n  info?: typeof console.info;\n  log?: typeof console.log;\n  table?: typeof console.table;\n  time?: typeof console.time;\n  timeEnd?: typeof console.timeEnd;\n  timeLog?: typeof console.timeLog;\n  trace?: typeof console.trace;\n  warn?: typeof console.warn;\n};\n\nexport type LogLevel = keyof Logger;\n\nfunction initLogObserver(\n  cb: logCallback,\n  win: IWindow, // top window or in an iframe\n  options: LogRecordOptions,\n): listenerHandler {\n  const logOptions = (\n    options ? Object.assign({}, defaultLogOptions, options) : defaultLogOptions\n  ) as {\n    level: LogLevel[];\n    lengthThreshold: number;\n    stringifyOptions?: StringifyOptions;\n    logger: Logger | 'console';\n  };\n  const loggerType = logOptions.logger;\n  if (!loggerType) {\n    return () => {\n      //\n    };\n  }\n  let logger: Logger;\n  if (typeof loggerType === 'string') {\n    logger = win[loggerType];\n  } else {\n    logger = loggerType;\n  }\n  let logCount = 0;\n  let inStack = false;\n  const cancelHandlers: listenerHandler[] = [];\n  // add listener to thrown errors\n  if (logOptions.level.includes('error')) {\n    const errorHandler = (event: ErrorEvent) => {\n      const message = event.message,\n        error = event.error as Error;\n      const trace: string[] = ErrorStackParser.parse(error).map(\n        (stackFrame: StackFrame) => stackFrame.toString(),\n      );\n      const payload = [stringify(message, logOptions.stringifyOptions)];\n      cb({\n        level: 'error',\n        trace,\n        payload,\n      });\n    };\n    win.addEventListener('error', errorHandler);\n    cancelHandlers.push(() => {\n      win.removeEventListener('error', errorHandler);\n    });\n    const unhandledrejectionHandler = (event: PromiseRejectionEvent) => {\n      let error: Error;\n      let payload: string[];\n      if (event.reason instanceof Error) {\n        error = event.reason;\n        payload = [\n          stringify(\n            `Uncaught (in promise) ${error.name}: ${error.message}`,\n            logOptions.stringifyOptions,\n          ),\n        ];\n      } else {\n        error = new Error();\n        payload = [\n          stringify('Uncaught (in promise)', logOptions.stringifyOptions),\n          stringify(event.reason, logOptions.stringifyOptions),\n        ];\n      }\n      const trace: string[] = ErrorStackParser.parse(error).map(\n        (stackFrame: StackFrame) => stackFrame.toString(),\n      );\n      cb({\n        level: 'error',\n        trace,\n        payload,\n      });\n    };\n    win.addEventListener('unhandledrejection', unhandledrejectionHandler);\n    cancelHandlers.push(() => {\n      win.removeEventListener('unhandledrejection', unhandledrejectionHandler);\n    });\n  }\n  for (const levelType of logOptions.level) {\n    cancelHandlers.push(replace(logger, levelType));\n  }\n  return () => {\n    cancelHandlers.forEach((h) => h());\n  };\n\n  /**\n   * replace the original console function and record logs\n   * @param logger - the logger object such as Console\n   * @param level - the name of log function to be replaced\n   */\n  function replace(_logger: Logger, level: LogLevel) {\n    if (!_logger[level]) {\n      return () => {\n        //\n      };\n    }\n    // replace the logger.{level}. return a restore function\n    return patch(\n      _logger,\n      level,\n      (original: (...args: Array<unknown>) => void) => {\n        return (...args: Array<unknown>) => {\n          original.apply(this, args);\n\n          if (level === 'assert' && !!args[0]) {\n            // assert does not log if the first argument evaluates to true\n            return;\n          }\n\n          if (inStack) {\n            // If we are already in a stack this means something from the following code is calling a console method\n            // likely a proxy method called from stringify. We don't want to log this as it will cause an infinite loop\n            return;\n          }\n          inStack = true;\n          try {\n            const trace = ErrorStackParser.parse(new Error())\n              .map((stackFrame: StackFrame) => stackFrame.toString())\n              .splice(1); // splice(1) to omit the hijacked log function\n\n            // assert does not log its first arg, that's only used for deciding whether to log\n            const argsForPayload = level === 'assert' ? args.slice(1) : args;\n\n            const payload = argsForPayload.map((s) =>\n              stringify(s, logOptions.stringifyOptions),\n            );\n            logCount++;\n            if (logCount < logOptions.lengthThreshold) {\n              cb({\n                level,\n                trace,\n                payload,\n              });\n            } else if (logCount === logOptions.lengthThreshold) {\n              // notify the user\n              cb({\n                level: 'warn',\n                trace: [],\n                payload: [\n                  stringify('The number of log records reached the threshold.'),\n                ],\n              });\n            }\n          } catch (error) {\n            original('rrweb logger error:', error, ...args);\n          } finally {\n            inStack = false;\n          }\n        };\n      },\n    );\n  }\n}\n\nexport const PLUGIN_NAME = 'rrweb/console@1';\n\nexport const getRecordConsolePlugin: (\n  options?: LogRecordOptions,\n) => RecordPlugin = (options) => ({\n  name: PLUGIN_NAME,\n  observer: initLogObserver,\n  options: options,\n});\n"],"names":[],"mappings":"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"}